import os
import math

def generate_header_file(file_path, MaxNTTPCount):
    file_name = os.path.basename(file_path)
    # Insert a "_IMPL" at the end of the file name
    header_guard_split = file_name.upper().rsplit('.', 1)
    header_guard = header_guard_split[0] + "_IMPL_" + header_guard_split[1]

    with open(file_path, "w") as f:
        # Write header
        f.write("// This file is generated by a python script. It provides a convienient helper\n")
        f.write("// that encodes NTTP as std::integral_constants types. This is especially\n")
        f.write("// helpful when there are a large number of NTTPs.\n\n")

        f.write(f"#ifndef {header_guard}\n")
        f.write(f"#define {header_guard}\n\n")

        # Write the includes
        f.write("#include <tuple>\n")
        f.write("\n")

        # Write the namespaces
        f.write("namespace cex_for_loop {\n")

        # Generate the helper
        f.write("template <typename BodyFunctor,\n")
        f.write("          std::size_t NTTPCount =\n")
        f.write("              std::tuple_size<typename BodyFunctor::OutputType>::value - 1>\n")
        f.write("struct TypeEncodedNTTPs;\n\n")

        f.write("template <typename BodyFunctor>\n")
        f.write("struct TypeEncodedNTTPs<BodyFunctor, 0> {\n")
        f.write("  using type = std::tuple<>;\n")
        f.write("};\n\n")

        for i in range(MaxNTTPCount):
            f.write("template <typename BodyFunctor>\n")
            f.write(f"struct TypeEncodedNTTPs<BodyFunctor, {i + 1}> {{\n")
            f.write("  template <\n")
            f.write("      // clang-format off\n")
            for j in range(i + 1):
                f.write(f"    std::tuple_element_t<{j + 1}, typename BodyFunctor::OutputType>\n")
                f.write(f"        InitialNTTPValue{j}")
                if j != i:
                    f.write(",\n")
            f.write(">\n")
            f.write("  // clang-format on\n")
            f.write("  using type = std::tuple<\n")
            for j in range(i + 1):
                f.write(f"      std::integral_constant<decltype(InitialNTTPValue{j}), InitialNTTPValue{j}>")
                if j == i:
                    f.write(">;\n")
                else:
                    f.write(",\n")
            f.write("};\n\n")

        # Close the namespaces and header guard
        f.write("}  // namespace cex_for_loop\n\n")
        f.write(f"#endif  // {header_guard}\n")

gen_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "type_encoded_nttps_helper.h")

generate_header_file(gen_file_path, 15)
