# This python script is used to generate the Exponentially instantiated CEX For Loop. 
# This allows one to subvert the compiler's template depth limit (900 for clang and gcc).
# Instead of instantiating linearly, the implementation instantiates along an N-ary tree
# meaning the iteration count versus the maximum used template depth has the 
# relationship O(n) = log(n). A more detailed description and the graph can be found
# here: https://www.desmos.com/calculator/izvr4h3xbs

import os
import math

def get_lower_bound(linear_expansion_length, n, i):
    if i == 0:
        return 0
    return int(1 + (i * math.pow(linear_expansion_length, n)))

def get_upper_bound(linear_expansion_length, n, i):
    return int(1 + ((i+1) * math.pow(linear_expansion_length, n)))

def generate_header_file(file_path, linear_expansion_length, linear_expansion_count):
    file_name = os.path.basename(file_path)
    # Insert a "_IMPL" at the end of the file name
    header_guard_split = file_name.upper().rsplit('.', 1)
    header_guard = header_guard_split[0] + "_IMPL_" + header_guard_split[1]

    with open(file_path, "w") as f:
        # Write header
        f.write("// This file is generated by a python script because its essientially an\n")
        f.write("// unrolled recursive structure. The CEX For Loop is instantiated Exponentially.\n")
        f.write("// This allows one to subvert the compiler's template depth limit (900 for clang\n")
        f.write("// and gcc). Instead of instantiating linearly, the implementation instantiates\n")
        f.write("// along an N-ary tree meaning the iteration count versus the maximum used\n")
        f.write("// template depth has the relationship O(n) = log(n). A more detailed\n")
        f.write("// description and the graph can be found here:\n")
        f.write("// https://www.desmos.com/calculator/izvr4h3xbs\n\n")

        f.write(f"#ifndef {header_guard}\n")
        f.write(f"#define {header_guard}\n\n")

        # Write the includes
        f.write("#include <cstddef>\n")
        f.write("#include <tuple>\n")
        f.write("#include <type_traits>\n\n")
        f.write("#include \"../bool_expression_functors.h\"\n")
        f.write("\n")

        # Write the namespaces
        f.write("namespace cex_for_loop {\n")
        f.write("namespace impl {\n\n")

        f.write("template <typename T>\n")
        f.write("struct RemoveFirstTypeOfTuple {};\n")
        f.write("template <typename T, typename... Ts>\n")
        f.write("struct RemoveFirstTypeOfTuple<std::tuple<T, Ts...>> {\n")
        f.write("  using type = std::tuple<Ts...>;\n")
        f.write("};\n")

        f.write("template <typename IType>\n")
        f.write("static constexpr IType ceil_division(IType num, IType den) {\n")
        f.write("  return (num + (num % den)) / den;\n")
        f.write("}\n\n")

        f.write("template <typename IType>\n")
        f.write("static constexpr IType floor_division(IType num, IType den) {\n")
        f.write("  return (num - (num % den)) / den;\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType Start, IType End, IType Inc,\n")
        f.write("          typename LocalBoolExpressionFunctor>\n")
        f.write("static constexpr auto GetIterationCount()\n")
        f.write("    -> std::enable_if_t<\n")
        f.write("        (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                      cex_for_loop::BoolExpressionFunctor_LT>::value) ||\n")
        f.write("            (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                          cex_for_loop::BoolExpressionFunctor_GT>::value),\n")
        f.write("        IType> {\n")
        f.write("  return floor_division((End - Start), Inc);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType Start, IType End, IType Inc,\n")
        f.write("          typename LocalBoolExpressionFunctor>\n")
        f.write("static constexpr auto GetIterationCount()\n")
        f.write("    -> std::enable_if_t<\n")
        f.write("        (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                      cex_for_loop::BoolExpressionFunctor_LEQ>::value) ||\n")
        f.write("            (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                          cex_for_loop::BoolExpressionFunctor_GEQ>::value),\n")
        f.write("        IType> {\n")
        f.write("  return ceil_division((End - Start), Inc);\n")
        f.write("}\n")

        f.write("template <typename IType>\n")
        f.write("// NOLINTNEXTLINE(misc-no-recursion)\n")
        f.write("constexpr IType IntegralPow(IType Base, IType Exponent) {\n")
        f.write("  return Exponent == 0 ? 1 : Base * IntegralPow(Base, Exponent - 1);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType LocalStart, IType Inc,\n")
        f.write("          IType LinearExpansionIndex, IType I>\n")
        f.write("constexpr IType GetExpansionStart() {\n")
        f.write("  constexpr IType kStepSize =\n")
        f.write(f"      IntegralPow(static_cast<IType>({linear_expansion_length}), LinearExpansionIndex);\n")
        f.write("\n")
        f.write("  return LocalStart + (I * kStepSize * Inc);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType LocalStart, IType LocalEnd, IType Inc,\n")
        f.write("          IType LinearExpansionIndex, IType I>\n")
        f.write("constexpr IType GetExpansionEnd() {\n")
        f.write("  constexpr IType kStepSize =\n")
        f.write(f"      IntegralPow(static_cast<IType>({linear_expansion_length}), LinearExpansionIndex);\n")
        f.write("  constexpr IType kCalculatedEnd =\n")
        f.write("      GetExpansionStart<IType, LocalStart, Inc, LinearExpansionIndex, I>() +\n")
        f.write("      (kStepSize * Inc);\n")
        f.write("  return (LocalEnd > kCalculatedEnd) ? kCalculatedEnd : LocalEnd;\n")
        f.write("}\n")

        f.write("template <std::size_t N, typename TupleType>\n")
        f.write("using NthTypeOfTuple = typename std::tuple_element<N, TupleType>::type;\n\n")

        f.write("template <typename IType, IType Start, IType End, IType Inc,\n")
        f.write("          typename BoolExpressionFunctor, typename BodyFunctor,\n")
        f.write("          typename TupleWithTypeEncodedNTTPs, typename InitialDataFunctor>\n")
        f.write("class NAryTreeCEXForLoop {\n")
        f.write(" private:\n")

        f.write("  using FunctorData = typename BodyFunctor::NonConstexprData;\n")
        f.write("  using FunctorOutputType = typename BodyFunctor::OutputType;\n\n")

        f.write("  static_assert(\n")
        f.write(f"      IntegralPow({linear_expansion_length}, {linear_expansion_count}) >=\n")
        f.write("          GetIterationCount<IType, Start, End, Inc, BoolExpressionFunctor>(),\n")
        f.write("      \"Requested iteration is greater than supported maximum iteration \"\n")
        f.write("      \"count\");\n")

        f.write("  // clang-format off\n")
        f.write("  template <NthTypeOfTuple<1, FunctorOutputType> NTTP0Value>\n")
        f.write("  using NextTupleWithTypeEncodedNTTPs = std::tuple<\n")
        f.write("      std::integral_constant<NthTypeOfTuple<1, FunctorOutputType>, NTTP0Value>\n")
        f.write("      >;\n")
        f.write("  // clang-format on\n\n")

        for n in range(linear_expansion_count):
            f.write("  template <IType LocalStart, IType LocalEnd,\n")
            f.write("            typename LocalTupleWithTypeEncodedNTTPs,\n")
            f.write("            typename LocalInitialDataFunctor>\n")
            f.write(f"  struct LinearExpansion{n} {{\n")
            f.write("    static constexpr IType kLocalIterationCount =\n")
            f.write("        GetIterationCount<IType, LocalStart, LocalEnd, Inc,\n")
            f.write("                          BoolExpressionFunctor>();\n\n")

            f.write(f"    // Forward-declare iteration structs for partial template specialization\n")
            f.write("    // SFINAE\n")
            if n == 0:
                f.write("    template <typename UnusedType = void, typename Picker = void>\n")
                f.write("    struct INone;\n")
            for i in range(linear_expansion_length):
                f.write("    template <typename UnusedType = void, typename Picker = void>\n")
                f.write(f"    struct I{i};\n")
            f.write("\n")

            if n == 0:
                f.write("    // Define pratial template specializations for base iteration structs that\n")
                f.write("    // conditionaly instantiate the user BodyFunctor based on iteration count\n")
                f.write("    template <typename UnusedType>\n")
                f.write("    struct INone<UnusedType,\n")
                f.write("                 std::enable_if_t<kLocalIterationCount == 0, void>> {\n")
                f.write("      static constexpr FunctorOutputType kPriorOutput = {\n")
                f.write("          LocalInitialDataFunctor::value,\n")
                f.write("          NthTypeOfTuple<0, LocalTupleWithTypeEncodedNTTPs>::value};\n")
                f.write("\n")
                f.write("      // NOLINTNEXTLINE(readability-identifier-naming)\n")
                f.write("      static constexpr auto kValue = kPriorOutput;\n")
                f.write("    };\n")
                for i in range(linear_expansion_length):
                    f.write("    template <typename UnusedType>\n")
                    f.write(f"    struct I{i}<UnusedType, std::enable_if_t<kLocalIterationCount >= {i+1}, void>> {{\n")
                    if i == 0:
                        f.write("      static constexpr FunctorOutputType kPriorOutput = {\n")
                        f.write("          LocalInitialDataFunctor::value,\n")
                        f.write("          NthTypeOfTuple<0, LocalTupleWithTypeEncodedNTTPs>::value};\n")
                    else:
                        f.write(f"      static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n")
                    f.write("\n")

                    f.write("      // NOLINTNEXTLINE(readability-identifier-naming)\n")
                    f.write("      static constexpr auto kValue =\n")
                    f.write(f"          BodyFunctor::template func<(LocalStart + {i}),\n")
                    f.write("                                     std::get<1>(kPriorOutput)>(\n")
                    f.write("              std::get<0>(kPriorOutput));\n")
                    f.write("    };\n")

                f.write("    // Create SFINAE function that returns the value from the last iteration\n")
                f.write("    template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                f.write("    static constexpr auto func()\n")
                f.write(f"        -> std::enable_if_t<LocalLocalIterationCount == 0, FunctorOutputType> {{\n")
                f.write("      return INone<>::kValue;\n")
                f.write("    }\n")
                for i in range(linear_expansion_length):
                    f.write("    template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                    f.write("    static constexpr auto func()\n")
                    f.write(f"        -> std::enable_if_t<LocalLocalIterationCount == {i+1}, FunctorOutputType> {{\n")
                    f.write(f"      return I{i}<>::kValue;\n")
                    f.write("    }\n")
                f.write("  };\n\n")
            else:
                for i in range(linear_expansion_length):
                    f.write("    template <typename UnusedType>\n")
                    f.write(f"    struct I{i}<UnusedType, std::enable_if_t<(kLocalIterationCount >= {get_lower_bound(linear_expansion_length, n, i)}), void>> {{\n")
                    if i == 0:
                        f.write("      // NOLINTNEXTLINE(readability-identifier-naming)\n")
                        f.write(f"      static constexpr auto kValue = LinearExpansion{n-1}<\n")
                        f.write(f"          GetExpansionStart<IType, LocalStart, Inc, {n}, {i}>(),\n")
                        f.write(f"          GetExpansionEnd<IType, LocalStart, LocalEnd, Inc, {n}, {i}>(),\n")
                        f.write("          LocalTupleWithTypeEncodedNTTPs, LocalInitialDataFunctor>::func();\n")
                        f.write("    };\n")
                    else:
                        f.write(f"      static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n\n")

                        f.write("      struct NextInitialDataFunctor {\n")
                        f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                        f.write("        static constexpr FunctorData value = std::get<0>(kPriorOutput);\n")
                        f.write("      };\n\n")

                        f.write("      // NOLINTNEXTLINE(readability-identifier-naming)\n")
                        f.write(f"      static constexpr auto kValue = LinearExpansion{n-1}<\n")
                        f.write(f"          GetExpansionStart<IType, LocalStart, Inc, {n}, {i}>(),\n")
                        f.write(f"          GetExpansionEnd<IType, LocalStart, LocalEnd, Inc, {n}, {i}>(),\n")
                        f.write("          NextTupleWithTypeEncodedNTTPs<std::get<1>(kPriorOutput)>,\n")
                        f.write("          NextInitialDataFunctor>::func();\n")
                        f.write("    };\n")

                f.write("    // Create SFINAE function that returns the value from the last iteration\n")
                for i in range(linear_expansion_length):
                    f.write("    template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                    f.write("    static constexpr auto func()\n")
                    f.write(f"        -> std::enable_if_t<(LocalLocalIterationCount >= {get_lower_bound(linear_expansion_length, n, i)}) &&\n")
                    f.write(f"                                (LocalLocalIterationCount < {get_upper_bound(linear_expansion_length, n, i)}),\n")
                    f.write("                            FunctorOutputType> {\n")
                    f.write(f"      return I{i}<>::kValue;\n")
                    f.write("    }\n")

                f.write("  };\n\n")

        # Provide the interface
        f.write(" public:\n")
        f.write("  static constexpr FunctorOutputType func() {\n")
        f.write("    return LinearExpansion6<Start, End, TupleWithTypeEncodedNTTPs,\n")
        f.write("                            InitialDataFunctor>::func();\n")
        f.write("  }\n")

        # Close the struct, namespaces, and header guard
        f.write("};\n\n")  # Close LinearCEXForFunctor
        f.write("}  // namespace impl\n")
        f.write("}  // namespace cex_for_loop\n\n")
        f.write(f"#endif  // {header_guard}\n")

gen_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "nary_tree_cex_for_loop.h")

generate_header_file(gen_file_path, 10, 7)  # max iteration count = second_last_param**(last_param)
