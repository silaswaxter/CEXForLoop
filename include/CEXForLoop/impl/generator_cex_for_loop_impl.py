# This python script is used to generate the Exponentially instantiated CEX For Loop. 
# This allows one to subvert the compiler's template depth limit (900 for clang and gcc).
# Instead of instantiating linearly, the implementation instantiates along an N-ary tree
# meaning the iteration count versus the maximum used template depth has the 
# relationship O(n) = log(n). A more detailed description and the graph can be found
# here: https://www.desmos.com/calculator/izvr4h3xbs

import os
import math

def get_start(linear_expansion_length, nth_linear_expansion, ith_iteration_index):
    return int(ith_iteration_index * math.pow(linear_expansion_length, nth_linear_expansion))

def get_upper_bound(linear_expansion_length, n, i):
    return int(1 + ((i+1) * math.pow(linear_expansion_length, n)))

def generate_header_file(file_path, max_nttp_count, linear_expansion_length, linear_expansion_count):
    file_name = os.path.basename(file_path)
    # Insert a "_IMPL" at the end of the file name
    header_guard_split = file_name.upper().rsplit('.', 1)
    header_guard = header_guard_split[0] + "_IMPL_" + header_guard_split[1]

    with open(file_path, "w") as f:
        # Write header
        f.write("// This file is generated by a python script because its essientially an\n")
        f.write("// unrolled recursive structure. The CEX For Loop is instantiated Exponentially.\n")
        f.write("// This allows one to subvert the compiler's template depth limit (900 for clang\n")
        f.write("// and gcc). Instead of instantiating linearly, the implementation instantiates\n")
        f.write("// along an N-ary tree meaning the iteration count versus the maximum used\n")
        f.write("// template depth has the relationship O(n) = log(n). A more detailed\n")
        f.write("// description and the graph can be found here:\n")
        f.write("// https://www.desmos.com/calculator/izvr4h3xbs\n\n")

        f.write(f"#ifndef {header_guard}\n")
        f.write(f"#define {header_guard}\n\n")

        # Write the includes
        f.write("#include <cstddef>\n")
        f.write("#include <tuple>\n")
        f.write("#include <type_traits>\n")
        f.write("\n")
        f.write("#include \"../type_encoded_nttps_helper.h\"\n")
        f.write("\n")

        # Write the namespaces
        f.write("namespace cex_for_loop {\n")
        f.write("namespace impl {\n\n")

        f.write("template <typename T>\n")
        f.write("struct RemoveFirstTypeOfTuple {};\n")
        f.write("template <typename T, typename... Ts>\n")
        f.write("struct RemoveFirstTypeOfTuple<std::tuple<T, Ts...>> {\n")
        f.write("  using type = std::tuple<Ts...>;\n")
        f.write("};\n")

        f.write("template <typename IType>\n")
        f.write("// NOLINTNEXTLINE(misc-no-recursion)\n")
        f.write("constexpr IType IntegralPow(IType Base, IType Exponent) {\n")
        f.write("  return Exponent == 0 ? 1 : Base * IntegralPow(Base, Exponent - 1);\n")
        f.write("}\n\n")

        f.write("template <std::size_t N, typename TupleType>\n")
        f.write("using NthTypeOfTuple = typename std::tuple_element<N, TupleType>::type;\n\n")


        f.write("template <typename BoolExpressionFunctor, typename IType>\n")
        f.write("static constexpr int GetEnabledIteration(IType LocalStart, IType Inc, IType End,\n")
        f.write("                                         IType NthExpansion) {\n")
        f.write("  int return_value = -1;\n")
        for i in range(linear_expansion_length):
            f.write("  if (BoolExpressionFunctor::template WithType<IType>::func(\n")
            f.write("          LocalStart +\n")
            f.write(f"              ({i} * IntegralPow(static_cast<IType>({linear_expansion_length}), NthExpansion) * Inc),\n")
            f.write("          End)) {\n")
            f.write(f"    return_value = {i};\n")
            f.write("  } else {\n")
            f.write("    return return_value;\n")
            f.write("  }\n")
        f.write("  return return_value;\n")
        f.write("}\n\n")

        f.write("// Declare non-specialized template enabling selection of implementation\n")
        f.write("// depending on the number of NTTPs\n")
        f.write("template <typename BodyFunctor,\n")
        f.write("          std::size_t NTTPCount =\n")
        f.write("              std::tuple_size<typename BodyFunctor::OutputType>::value - 1>\n")
        f.write("struct NAryTreeCEXForLoop;\n\n")

        for t in range(max_nttp_count):
            f.write("template <typename BodyFunctor>\n")
            f.write(f"struct NAryTreeCEXForLoop<BodyFunctor, {t}> {{\n")

            f.write("  template <typename IType, IType Start, IType End, IType Inc,\n")
            f.write("            typename BoolExpressionFunctor,\n")
            f.write("            typename InitialTupleWithTypeEncodedNTTPs,\n")
            f.write("            typename InitialNonCEXDataFunctor>\n")
            f.write("  class With {\n")
            f.write("   private:\n")

            f.write("    using FunctorData = typename BodyFunctor::NonConstexprData;\n")
            f.write("    using FunctorOutputType = typename BodyFunctor::OutputType;\n\n")

            if t == 0:
                f.write("    struct NTTP1Hider {\n")
                f.write("      using NonConstexprData = FunctorData;\n\n")
                f.write("      using OutputType = std::tuple<NonConstexprData, int>;\n\n")

                f.write("      template <IType I, int DummyNTTP>\n")
                f.write("      static constexpr OutputType func(NonConstexprData input_data) {\n")
                f.write("        FunctorData data =\n")
                f.write("            std::get<0>(BodyFunctor::template func<I>(input_data));\n")
                f.write("        return {data, DummyNTTP};\n")
                f.write("      };\n")
                f.write("    };\n\n")

                f.write("   public:\n")
                f.write("    static constexpr FunctorOutputType func() {\n")
                f.write("      return std::get<0>(NAryTreeCEXForLoop<NTTP1Hider, 1>::template With<\n")
                f.write("                         IType, Start, End, Inc, BoolExpressionFunctor,\n")
                f.write("                         std::tuple<std::integral_constant<int, 0>>,\n")
                f.write("                         InitialNonCEXDataFunctor>::func());\n")
                f.write("    }\n")
                f.write("  };\n")
            else:
                for n in range(linear_expansion_count):
                    f.write("    template <IType LocalStart,\n")
                    f.write("              typename LocalInitialTupleWithTypeEncodedNTTPs,\n")
                    f.write("              typename LocalInitialNonCEXDataFunctor>\n")
                    f.write(f"    struct LinearExpansion{n} {{\n")
                    f.write("      static constexpr auto kEnabledIteration =\n")
                    f.write("          GetEnabledIteration<BoolExpressionFunctor, IType>(LocalStart, Inc,\n")
                    f.write(f"                                                            End, {n});\n\n")

                    f.write(f"      // Forward-declare iteration structs for partial template specialization\n")
                    f.write("      // SFINAE\n")
                    if n == 0:
                        f.write("      template <typename UnusedType = void, typename Picker = void>\n")
                        f.write("      struct INone;\n")
                    for i in range(linear_expansion_length):
                        f.write("      template <typename UnusedType = void, typename Picker = void>\n")
                        f.write(f"      struct I{i};\n")
                    f.write("  \n")

                    if n == 0:
                        f.write("      // Define partial template specializations for base iteration structs that\n")
                        f.write("      // conditionaly instantiate the user BodyFunctor based on iteration count\n")
                        f.write("      template <typename UnusedType>\n")
                        f.write("      struct INone<UnusedType,\n")
                        f.write("                   std::enable_if_t<kEnabledIteration == -1, void>> {\n")
                        f.write("        static constexpr FunctorOutputType kPriorOutput = {\n")
                        f.write("            LocalInitialNonCEXDataFunctor::value")
                        if t != 0:
                            f.write(",\n")
                        for y in range(t):
                            f.write(f"            NthTypeOfTuple<{y}, LocalInitialTupleWithTypeEncodedNTTPs>::value")
                            if y != t - 1:
                                f.write(",\n")
                        f.write("};\n")
                        f.write("  \n")
                        f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                        f.write("        static constexpr auto kValue = kPriorOutput;\n")
                        f.write("      };\n")

                        for i in range(linear_expansion_length):
                            f.write("      template <typename UnusedType>\n")
                            f.write(f"      struct I{i}<UnusedType, std::enable_if_t<kEnabledIteration >= {i}, void>> {{\n")
                            if i == 0:
                                f.write("        static constexpr FunctorOutputType kPriorOutput = {\n")
                                f.write("            LocalInitialNonCEXDataFunctor::value")
                                if t != 0:
                                    f.write(",\n")
                                for y in range(t):
                                    f.write(f"            NthTypeOfTuple<{y}, LocalInitialTupleWithTypeEncodedNTTPs>::value")
                                    if y != t - 1:
                                        f.write(",\n")
                                f.write("};\n")
                            else:
                                f.write(f"        static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n")
                            f.write("  \n")

                            f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                            f.write("        static constexpr auto kValue =\n")
                            f.write(f"            BodyFunctor::template func<(LocalStart + ({i} * Inc))")
                            if t != 0:
                                f.write(",\n")
                            for y in range(t):
                                f.write(f"                                       std::get<{y+1}>(kPriorOutput)")
                                if y != t - 1:
                                    f.write(",\n")
                            f.write(">(\n")
                            f.write("                std::get<0>(kPriorOutput));\n")
                            f.write("      };\n")

                        f.write("      // Create SFINAE function that returns the value from the last iteration\n")
                        f.write("      template <int LastEnabledI = kEnabledIteration>\n")
                        f.write("      static constexpr auto func()\n")
                        f.write("          -> std::enable_if_t<LastEnabledI == -1, FunctorOutputType> {\n")
                        f.write("        return INone<>::kValue;\n")
                        f.write("      }\n")
                        for i in range(linear_expansion_length):
                            f.write("      template <int LastEnabledI = kEnabledIteration>\n")
                            f.write("      static constexpr auto func()\n")
                            f.write(f"          -> std::enable_if_t<LastEnabledI == {i}, FunctorOutputType> {{\n")
                            f.write(f"        return I{i}<>::kValue;\n")
                            f.write("      }\n")
                        f.write("    };\n\n")
                    else:
                        for i in range(linear_expansion_length):
                            f.write("      template <typename UnusedType>\n")
                            if i == 0:
                                f.write(f"      struct I{i}<UnusedType, std::enable_if_t<(kEnabledIteration >= -1), void>> {{\n")
                                f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                                f.write(f"        static constexpr auto kValue = LinearExpansion{n-1}<\n")
                                f.write(f"           LocalStart + (Inc * {get_start(linear_expansion_length, n, i)}),\n")
                                f.write("            LocalInitialTupleWithTypeEncodedNTTPs,\n")
                                f.write("            LocalInitialNonCEXDataFunctor>::func();\n")
                                f.write("      };\n")
                            else:
                                f.write(f"      struct I{i}<UnusedType, std::enable_if_t<(kEnabledIteration >= {i}), void>> {{\n")
                                f.write(f"        static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n\n")

                                f.write("        struct NextInitialNonCEXDataFunctor {\n")
                                f.write("          // NOLINTNEXTLINE(readability-identifier-naming)\n")
                                f.write("          static constexpr FunctorData value = std::get<0>(kPriorOutput);\n")
                                f.write("        };\n\n")

                                f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                                f.write(f"        static constexpr auto kValue = LinearExpansion{n-1}<\n")
                                f.write(f"           LocalStart + (Inc * {get_start(linear_expansion_length, n, i)}),\n")
                                if t == 0:
                                    f.write("            typename TemplateDepthEnforcer<BodyFunctor>::template type<decltype(std::get<0>(kPriorOutput))>,\n")
                                else:
                                    f.write("            typename TypeEncodedNTTPs<BodyFunctor>::template type<\n")
                                for y in range(t):
                                    f.write(f"                std::get<{y + 1}>(kPriorOutput)")
                                    if y != t - 1:
                                        f.write(",\n")
                                    else:
                                        f.write(">,\n")
                                f.write("            NextInitialNonCEXDataFunctor>::func();\n")
                                f.write("      };\n")

                        f.write("      // Create SFINAE function that returns the value from the last iteration\n")
                        for i in range(linear_expansion_length):
                            f.write("      template <int LastEnabledI = kEnabledIteration>\n")
                            f.write("      static constexpr auto func()\n")
                            if i == 0:
                                f.write("          -> std::enable_if_t<LastEnabledI <= 0, FunctorOutputType> {\n")
                            else:
                                f.write(f"          -> std::enable_if_t<LastEnabledI == {i}, FunctorOutputType> {{\n")
                            f.write(f"        return I{i}<>::kValue;\n")
                            f.write("      }\n")

                        f.write("    };\n")

                # Provide the interface
                f.write("   public:\n")
                f.write("    static constexpr FunctorOutputType func() {\n")
                f.write(f"      return LinearExpansion{linear_expansion_count - 1}<Start, InitialTupleWithTypeEncodedNTTPs,\n")
                f.write("                              InitialNonCEXDataFunctor>::func();\n")
                f.write("    }\n")
                f.write("  };\n")

            # Close this NTTP Count's struct
            f.write("};\n\n")

        # Close the namespaces and header guard
        f.write("}  // namespace impl\n")
        f.write("}  // namespace cex_for_loop\n\n")
        f.write(f"#endif  // {header_guard}\n")

gen_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "nary_tree_cex_for_loop.h")

generate_header_file(gen_file_path, 50, 10, 7)  # max iteration count = second_last_param**(last_param)
