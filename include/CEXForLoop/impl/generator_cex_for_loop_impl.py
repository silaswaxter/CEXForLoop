# This python script is used to generate the Exponentially instantiated CEX For Loop. 
# This allows one to subvert the compiler's template depth limit (900 for clang and gcc).
# Instead of instantiating linearly, the implementation instantiates along an N-ary tree
# meaning the iteration count versus the maximum used template depth has the 
# relationship O(n) = log(n). A more detailed description and the graph can be found
# here: https://www.desmos.com/calculator/izvr4h3xbs

import os
import math

def get_lower_bound(linear_expansion_length, n, i):
    if i == 0:
        return 0
    return int(1 + (i * math.pow(linear_expansion_length, n)))

def get_upper_bound(linear_expansion_length, n, i):
    return int(1 + ((i+1) * math.pow(linear_expansion_length, n)))

def generate_header_file(file_path, max_nttp_count, linear_expansion_length, linear_expansion_count):
    file_name = os.path.basename(file_path)
    # Insert a "_IMPL" at the end of the file name
    header_guard_split = file_name.upper().rsplit('.', 1)
    header_guard = header_guard_split[0] + "_IMPL_" + header_guard_split[1]

    with open(file_path, "w") as f:
        # Write header
        f.write("// This file is generated by a python script because its essientially an\n")
        f.write("// unrolled recursive structure. The CEX For Loop is instantiated Exponentially.\n")
        f.write("// This allows one to subvert the compiler's template depth limit (900 for clang\n")
        f.write("// and gcc). Instead of instantiating linearly, the implementation instantiates\n")
        f.write("// along an N-ary tree meaning the iteration count versus the maximum used\n")
        f.write("// template depth has the relationship O(n) = log(n). A more detailed\n")
        f.write("// description and the graph can be found here:\n")
        f.write("// https://www.desmos.com/calculator/izvr4h3xbs\n\n")

        f.write(f"#ifndef {header_guard}\n")
        f.write(f"#define {header_guard}\n\n")

        # Write the includes
        f.write("#include <cstddef>\n")
        f.write("#include <tuple>\n")
        f.write("#include <type_traits>\n\n")
        f.write("#include \"../bool_expression_functors.h\"\n")
        f.write("#include \"../type_encoded_nttps_helper.h\"\n")
        f.write("\n")

        # Write the namespaces
        f.write("namespace cex_for_loop {\n")
        f.write("namespace impl {\n\n")

        f.write("template <typename T>\n")
        f.write("struct RemoveFirstTypeOfTuple {};\n")
        f.write("template <typename T, typename... Ts>\n")
        f.write("struct RemoveFirstTypeOfTuple<std::tuple<T, Ts...>> {\n")
        f.write("  using type = std::tuple<Ts...>;\n")
        f.write("};\n")

        f.write("template <typename IType>\n")
        f.write("static constexpr IType ceil_division(IType num, IType den) {\n")
        f.write("  return (num + (num % den)) / den;\n")
        f.write("}\n\n")

        f.write("template <typename IType>\n")
        f.write("static constexpr IType floor_division(IType num, IType den) {\n")
        f.write("  return (num - (num % den)) / den;\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType Start, IType End, IType Inc,\n")
        f.write("          typename LocalBoolExpressionFunctor>\n")
        f.write("static constexpr auto GetIterationCount()\n")
        f.write("    -> std::enable_if_t<\n")
        f.write("        (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                      cex_for_loop::BoolExpressionFunctor_LT>::value) ||\n")
        f.write("            (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                          cex_for_loop::BoolExpressionFunctor_GT>::value),\n")
        f.write("        IType> {\n")
        f.write("  return floor_division((End - Start), Inc);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType Start, IType End, IType Inc,\n")
        f.write("          typename LocalBoolExpressionFunctor>\n")
        f.write("static constexpr auto GetIterationCount()\n")
        f.write("    -> std::enable_if_t<\n")
        f.write("        (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                      cex_for_loop::BoolExpressionFunctor_LEQ>::value) ||\n")
        f.write("            (std::is_same<LocalBoolExpressionFunctor,\n")
        f.write("                          cex_for_loop::BoolExpressionFunctor_GEQ>::value),\n")
        f.write("        IType> {\n")
        f.write("  return ceil_division((End - Start), Inc);\n")
        f.write("}\n")

        f.write("template <typename IType>\n")
        f.write("// NOLINTNEXTLINE(misc-no-recursion)\n")
        f.write("constexpr IType IntegralPow(IType Base, IType Exponent) {\n")
        f.write("  return Exponent == 0 ? 1 : Base * IntegralPow(Base, Exponent - 1);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType LocalStart, IType Inc,\n")
        f.write("          IType LinearExpansionIndex, IType I>\n")
        f.write("constexpr IType GetExpansionStart() {\n")
        f.write("  constexpr IType kStepSize =\n")
        f.write(f"      IntegralPow(static_cast<IType>({linear_expansion_length}), LinearExpansionIndex);\n")
        f.write("\n")
        f.write("  return LocalStart + (I * kStepSize * Inc);\n")
        f.write("}\n\n")

        f.write("template <typename IType, IType LocalStart, IType LocalEnd, IType Inc,\n")
        f.write("          IType LinearExpansionIndex, IType I>\n")
        f.write("constexpr IType GetExpansionEnd() {\n")
        f.write("  constexpr IType kStepSize =\n")
        f.write(f"      IntegralPow(static_cast<IType>({linear_expansion_length}), LinearExpansionIndex);\n")
        f.write("  constexpr IType kCalculatedEnd =\n")
        f.write("      GetExpansionStart<IType, LocalStart, Inc, LinearExpansionIndex, I>() +\n")
        f.write("      (kStepSize * Inc);\n")
        f.write("  return (LocalEnd > kCalculatedEnd) ? kCalculatedEnd : LocalEnd;\n")
        f.write("}\n")

        f.write("template <std::size_t N, typename TupleType>\n")
        f.write("using NthTypeOfTuple = typename std::tuple_element<N, TupleType>::type;\n\n")

        f.write("// Declare non-specialized template enabling selection of implementation\n")
        f.write("// depending on the number of NTTPs\n")
        f.write("template <typename BodyFunctor,\n")
        f.write("          std::size_t NTTPCount =\n")
        f.write("              std::tuple_size<typename BodyFunctor::OutputType>::value - 1>\n")
        f.write("struct NAryTreeCEXForLoop;\n\n")

        for t in range(max_nttp_count):
            f.write("template <typename BodyFunctor>\n")
            f.write(f"struct NAryTreeCEXForLoop<BodyFunctor, {t}> {{\n")

            f.write("  template <typename IType, IType Start, IType End, IType Inc,\n")
            f.write("            typename BoolExpressionFunctor,\n")
            f.write("            typename InitialTupleWithTypeEncodedNTTPs,\n")
            f.write("            typename InitialNonCEXDataFunctor>\n")
            f.write("  class With {\n")
            f.write("   private:\n")

            f.write("    using FunctorData = typename BodyFunctor::NonConstexprData;\n")
            f.write("    using FunctorOutputType = typename BodyFunctor::OutputType;\n\n")

            f.write("    static_assert(\n")
            f.write(f"        IntegralPow({linear_expansion_length}, {linear_expansion_count}) >=\n")
            f.write("            GetIterationCount<IType, Start, End, Inc, BoolExpressionFunctor>(),\n")
            f.write("        \"Requested iteration is greater than supported maximum iteration \"\n")
            f.write("        \"count\");\n\n")

            for n in range(linear_expansion_count):
                f.write("    template <IType LocalStart, IType LocalEnd,\n")
                f.write("              typename LocalInitialTupleWithTypeEncodedNTTPs,\n")
                f.write("              typename LocalInitialNonCEXDataFunctor>\n")
                f.write(f"    struct LinearExpansion{n} {{\n")
                f.write("      static constexpr IType kLocalIterationCount =\n")
                f.write("          GetIterationCount<IType, LocalStart, LocalEnd, Inc,\n")
                f.write("                            BoolExpressionFunctor>();\n\n")

                f.write(f"      // Forward-declare iteration structs for partial template specialization\n")
                f.write("      // SFINAE\n")
                if n == 0:
                    f.write("      template <typename UnusedType = void, typename Picker = void>\n")
                    f.write("      struct INone;\n")
                for i in range(linear_expansion_length):
                    f.write("      template <typename UnusedType = void, typename Picker = void>\n")
                    f.write(f"      struct I{i};\n")
                f.write("  \n")

                if n == 0:
                    f.write("      // Define pratial template specializations for base iteration structs that\n")
                    f.write("      // conditionaly instantiate the user BodyFunctor based on iteration count\n")
                    f.write("      template <typename UnusedType>\n")
                    f.write("      struct INone<UnusedType,\n")
                    f.write("                   std::enable_if_t<kLocalIterationCount == 0, void>> {\n")
                    f.write("        static constexpr FunctorOutputType kPriorOutput = {\n")
                    f.write("            LocalInitialNonCEXDataFunctor::value")
                    if t != 0:
                        f.write(",\n")
                    for y in range(t):
                        f.write(f"            NthTypeOfTuple<{y}, LocalInitialTupleWithTypeEncodedNTTPs>::value")
                        if y != t - 1:
                            f.write(",\n")
                    f.write("};\n")
                    f.write("  \n")
                    f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                    f.write("        static constexpr auto kValue = kPriorOutput;\n")
                    f.write("      };\n")
                    for i in range(linear_expansion_length):
                        f.write("      template <typename UnusedType>\n")
                        f.write(f"      struct I{i}<UnusedType, std::enable_if_t<kLocalIterationCount >= {i+1}, void>> {{\n")
                        if i == 0:
                            f.write("        static constexpr FunctorOutputType kPriorOutput = {\n")
                            f.write("            LocalInitialNonCEXDataFunctor::value")
                            if t != 0:
                                f.write(",\n")
                            for y in range(t):
                                f.write(f"            NthTypeOfTuple<{y}, LocalInitialTupleWithTypeEncodedNTTPs>::value")
                                if y != t - 1:
                                    f.write(",\n")
                            f.write("};\n")
                        else:
                            f.write(f"        static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n")
                        f.write("  \n")

                        f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                        f.write("        static constexpr auto kValue =\n")
                        f.write(f"            BodyFunctor::template func<(LocalStart + {i})")
                        if t != 0:
                            f.write(",\n")
                        for y in range(t):
                            f.write(f"                                       std::get<{y+1}>(kPriorOutput)")
                            if y != t - 1:
                                f.write(",\n")
                        f.write(">(\n")
                        f.write("                std::get<0>(kPriorOutput));\n")
                        f.write("      };\n")

                    f.write("      // Create SFINAE function that returns the value from the last iteration\n")
                    f.write("      template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                    f.write("      static constexpr auto func()\n")
                    f.write(f"          -> std::enable_if_t<LocalLocalIterationCount == 0, FunctorOutputType> {{\n")
                    f.write("        return INone<>::kValue;\n")
                    f.write("      }\n")
                    for i in range(linear_expansion_length):
                        f.write("      template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                        f.write("      static constexpr auto func()\n")
                        f.write(f"          -> std::enable_if_t<LocalLocalIterationCount == {i+1}, FunctorOutputType> {{\n")
                        f.write(f"        return I{i}<>::kValue;\n")
                        f.write("      }\n")
                    f.write("    };\n\n")
                else:
                    for i in range(linear_expansion_length):
                        f.write("      template <typename UnusedType>\n")
                        f.write(f"      struct I{i}<UnusedType, std::enable_if_t<(kLocalIterationCount >= {get_lower_bound(linear_expansion_length, n, i)}), void>> {{\n")
                        if i == 0:
                            f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                            f.write(f"        static constexpr auto kValue = LinearExpansion{n-1}<\n")
                            f.write(f"            GetExpansionStart<IType, LocalStart, Inc, {n}, {i}>(),\n")
                            f.write(f"            GetExpansionEnd<IType, LocalStart, LocalEnd, Inc, {n}, {i}>(),\n")
                            f.write("            LocalInitialTupleWithTypeEncodedNTTPs,\n")
                            f.write("            LocalInitialNonCEXDataFunctor>::func();\n")
                            f.write("      };\n")
                        else:
                            f.write(f"        static constexpr FunctorOutputType kPriorOutput = I{i-1}<>::kValue;\n\n")

                            f.write("        struct NextInitialNonCEXDataFunctor {\n")
                            f.write("          // NOLINTNEXTLINE(readability-identifier-naming)\n")
                            f.write("          static constexpr FunctorData value = std::get<0>(kPriorOutput);\n")
                            f.write("        };\n\n")

                            f.write("        // NOLINTNEXTLINE(readability-identifier-naming)\n")
                            f.write(f"        static constexpr auto kValue = LinearExpansion{n-1}<\n")
                            f.write(f"            GetExpansionStart<IType, LocalStart, Inc, {n}, {i}>(),\n")
                            f.write(f"            GetExpansionEnd<IType, LocalStart, LocalEnd, Inc, {n}, {i}>(),\n")
                            f.write("            typename TypeEncodedNTTPs<BodyFunctor>::template type<\n")
                            for y in range(t):
                                f.write(f"                std::get<{y + 1}>(kPriorOutput)")
                                if y != t - 1:
                                    f.write(",\n")
                            f.write(">,\n")
                            f.write("            NextInitialNonCEXDataFunctor>::func();\n")
                            f.write("      };\n")

                    f.write("      // Create SFINAE function that returns the value from the last iteration\n")
                    for i in range(linear_expansion_length):
                        f.write("      template <IType LocalLocalIterationCount = kLocalIterationCount>\n")
                        f.write("      static constexpr auto func()\n")
                        f.write(f"          -> std::enable_if_t<(LocalLocalIterationCount >= {get_lower_bound(linear_expansion_length, n, i)}) &&\n")
                        f.write(f"                                  (LocalLocalIterationCount < {get_upper_bound(linear_expansion_length, n, i)}),\n")
                        f.write("                              FunctorOutputType> {\n")
                        f.write(f"        return I{i}<>::kValue;\n")
                        f.write("      }\n")

                    f.write("    };\n")

            # Provide the interface
            f.write("   public:\n")
            f.write("    static constexpr FunctorOutputType func() {\n")
            f.write("      return LinearExpansion6<Start, End, InitialTupleWithTypeEncodedNTTPs,\n")
            f.write("                              InitialNonCEXDataFunctor>::func();\n")
            f.write("    }\n")
            f.write("  };\n")

            # Close this NTTP Count's struct
            f.write("};\n\n")

        # Close the namespaces and header guard
        f.write("}  // namespace impl\n")
        f.write("}  // namespace cex_for_loop\n\n")
        f.write(f"#endif  // {header_guard}\n")

gen_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "nary_tree_cex_for_loop.h")

generate_header_file(gen_file_path, 3, 10, 7)  # max iteration count = second_last_param**(last_param)
