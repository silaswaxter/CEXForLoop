// This file is generated by a python script because its essientially an
// unrolled recursive structure. The CEX For Loop is instantiated Exponentially.
// This allows one to subvert the compiler's template depth limit (900 for clang
// and gcc). Instead of instantiating linearly, the implementation instantiates
// along an N-ary tree meaning the iteration count versus the maximum used
// template depth has the relationship O(n) = log(n). A more detailed
// description and the graph can be found here:
// https://www.desmos.com/calculator/izvr4h3xbs

#ifndef NARY_TREE_CEX_FOR_LOOP_IMPL_H
#define NARY_TREE_CEX_FOR_LOOP_IMPL_H

#include <cstddef>
#include <tuple>
#include <type_traits>
#include <array>

#include "../bool_expression_functors.h"
#include "../type_encoded_nttps_helper.h"

namespace cex_for_loop {
namespace impl {

template <typename T>
struct RemoveFirstTypeOfTuple {};
template <typename T, typename... Ts>
struct RemoveFirstTypeOfTuple<std::tuple<T, Ts...>> {
  using type = std::tuple<Ts...>;
};
template <typename IType>
static constexpr IType ceil_division(IType num, IType den) {
  return (num + (num % den)) / den;
}

template <typename IType>
static constexpr IType floor_division(IType num, IType den) {
  return (num - (num % den)) / den;
}

template <typename IType, IType Start, IType End, IType Inc,
          typename LocalBoolExpressionFunctor>
static constexpr auto GetIterationCount()
    -> std::enable_if_t<
        (std::is_same<LocalBoolExpressionFunctor,
                      cex_for_loop::BoolExpressionFunctor_LT>::value) ||
            (std::is_same<LocalBoolExpressionFunctor,
                          cex_for_loop::BoolExpressionFunctor_GT>::value),
        IType> {
  return floor_division((End - Start), Inc);
}

template <typename IType, IType Start, IType End, IType Inc,
          typename LocalBoolExpressionFunctor>
static constexpr auto GetIterationCount()
    -> std::enable_if_t<
        (std::is_same<LocalBoolExpressionFunctor,
                      cex_for_loop::BoolExpressionFunctor_LEQ>::value) ||
            (std::is_same<LocalBoolExpressionFunctor,
                          cex_for_loop::BoolExpressionFunctor_GEQ>::value),
        IType> {
  return ceil_division((End - Start), Inc);
}
template <typename IType>
// NOLINTNEXTLINE(misc-no-recursion)
constexpr IType IntegralPow(IType Base, IType Exponent) {
  return Exponent == 0 ? 1 : Base * IntegralPow(Base, Exponent - 1);
}

template <typename IType, IType LocalStart, IType Inc,
          IType LinearExpansionIndex, IType I>
constexpr IType GetExpansionStart() {
  constexpr IType kStepSize =
      IntegralPow(static_cast<IType>(10), LinearExpansionIndex);

  return LocalStart + (I * kStepSize * Inc);
}

template <typename IType, IType LocalStart, IType LocalEnd, IType Inc,
          IType LinearExpansionIndex, IType I>
constexpr IType GetExpansionEnd() {
  constexpr IType kStepSize =
      IntegralPow(static_cast<IType>(10), LinearExpansionIndex);
  constexpr IType kCalculatedEnd =
      GetExpansionStart<IType, LocalStart, Inc, LinearExpansionIndex, I>() +
      (kStepSize * Inc);
  return (LocalEnd > kCalculatedEnd) ? kCalculatedEnd : LocalEnd;
}
template <std::size_t N, typename TupleType>
using NthTypeOfTuple = typename std::tuple_element<N, TupleType>::type;

// Declare non-specialized template enabling selection of implementation
// depending on the number of NTTPs
template <typename BodyFunctor,
          std::size_t NTTPCount =
              std::tuple_size<typename BodyFunctor::OutputType>::value - 1>
struct NAryTreeCEXForLoop;

template <typename BodyFunctor>
struct NAryTreeCEXForLoop<BodyFunctor, 0> {
  template <typename IType, IType Start, IType End, IType Inc,
            typename BoolExpressionFunctor,
            typename InitialTupleWithTypeEncodedNTTPs,
            typename InitialNonCEXDataFunctor>
  class With {
   private:
    using FunctorData = typename BodyFunctor::NonConstexprData;
    using FunctorOutputType = typename BodyFunctor::OutputType;

    static_assert(
        IntegralPow(10, 1) >=
            GetIterationCount<IType, Start, End, Inc, BoolExpressionFunctor>(),
        "Requested iteration is greater than supported maximum iteration "
        "count");

    template <IType LocalStart, IType LocalEnd,
              typename LocalInitialTupleWithTypeEncodedNTTPs,
              typename LocalInitialNonCEXDataFunctor>
    struct LinearExpansion0 {
      static constexpr IType kLocalIterationCount =
          GetIterationCount<IType, LocalStart, LocalEnd, Inc,
                            BoolExpressionFunctor>();

      static constexpr int GetEnabledIteration() {
        int return_value = -1;
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (0 * Inc), End)) {
          return_value = 0;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (1 * Inc), End)) {
          return_value = 1;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (2 * Inc), End)) {
          return_value = 2;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (3 * Inc), End)) {
          return_value = 3;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (4 * Inc), End)) {
          return_value = 4;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (5 * Inc), End)) {
          return_value = 5;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (6 * Inc), End)) {
          return_value = 6;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (7 * Inc), End)) {
          return_value = 7;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (8 * Inc), End)) {
          return_value = 8;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (9 * Inc), End)) {
          return_value = 9;
        } else {
          return return_value;
        }
      }

      static constexpr auto kEnabledIterationCache = GetEnabledIteration();
      // Forward-declare iteration structs for partial template specialization
      // SFINAE
      template <typename UnusedType = void, typename Picker = void>
      struct INone;
      template <typename UnusedType = void, typename Picker = void>
      struct I0;
      template <typename UnusedType = void, typename Picker = void>
      struct I1;
      template <typename UnusedType = void, typename Picker = void>
      struct I2;
      template <typename UnusedType = void, typename Picker = void>
      struct I3;
      template <typename UnusedType = void, typename Picker = void>
      struct I4;
      template <typename UnusedType = void, typename Picker = void>
      struct I5;
      template <typename UnusedType = void, typename Picker = void>
      struct I6;
      template <typename UnusedType = void, typename Picker = void>
      struct I7;
      template <typename UnusedType = void, typename Picker = void>
      struct I8;
      template <typename UnusedType = void, typename Picker = void>
      struct I9;
  
      // Define partial template specializations for base iteration structs that
      // conditionaly instantiate the user BodyFunctor based on iteration count
      template <typename UnusedType>
      struct INone<UnusedType,
                   std::enable_if_t<kEnabledIterationCache == -1, void>> {
        static constexpr FunctorOutputType kPriorOutput = {
            LocalInitialNonCEXDataFunctor::value};
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue = kPriorOutput;
      };
      template <typename UnusedType>
      struct I0<UnusedType, std::enable_if_t<kEnabledIterationCache >= 0, void>> {
        static constexpr FunctorOutputType kPriorOutput = {
            LocalInitialNonCEXDataFunctor::value};
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 0)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I1<UnusedType, std::enable_if_t<kEnabledIterationCache >= 1, void>> {
        static constexpr FunctorOutputType kPriorOutput = I0<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 1)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I2<UnusedType, std::enable_if_t<kEnabledIterationCache >= 2, void>> {
        static constexpr FunctorOutputType kPriorOutput = I1<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 2)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I3<UnusedType, std::enable_if_t<kEnabledIterationCache >= 3, void>> {
        static constexpr FunctorOutputType kPriorOutput = I2<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 3)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I4<UnusedType, std::enable_if_t<kEnabledIterationCache >= 4, void>> {
        static constexpr FunctorOutputType kPriorOutput = I3<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 4)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I5<UnusedType, std::enable_if_t<kEnabledIterationCache >= 5, void>> {
        static constexpr FunctorOutputType kPriorOutput = I4<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 5)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I6<UnusedType, std::enable_if_t<kEnabledIterationCache >= 6, void>> {
        static constexpr FunctorOutputType kPriorOutput = I5<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 6)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I7<UnusedType, std::enable_if_t<kEnabledIterationCache >= 7, void>> {
        static constexpr FunctorOutputType kPriorOutput = I6<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 7)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I8<UnusedType, std::enable_if_t<kEnabledIterationCache >= 8, void>> {
        static constexpr FunctorOutputType kPriorOutput = I7<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 8)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I9<UnusedType, std::enable_if_t<kEnabledIterationCache >= 9, void>> {
        static constexpr FunctorOutputType kPriorOutput = I8<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 9)>(
                std::get<0>(kPriorOutput));
      };
      // Create SFINAE function that returns the value from the last iteration
      template <IType LocalLocalIterationCount = kLocalIterationCount>
      static constexpr auto func()
          -> std::enable_if_t<LocalLocalIterationCount == 0, FunctorOutputType> {
        return INone<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 0, FunctorOutputType> {
        return I0<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 1, FunctorOutputType> {
        return I1<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 2, FunctorOutputType> {
        return I2<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 3, FunctorOutputType> {
        return I3<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 4, FunctorOutputType> {
        return I4<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 5, FunctorOutputType> {
        return I5<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 6, FunctorOutputType> {
        return I6<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 7, FunctorOutputType> {
        return I7<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 8, FunctorOutputType> {
        return I8<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 9, FunctorOutputType> {
        return I9<>::kValue;
      }
    };

   public:
    static constexpr FunctorOutputType func() {
      return LinearExpansion0<Start, End, InitialTupleWithTypeEncodedNTTPs,
                              InitialNonCEXDataFunctor>::func();
    }
  };
};

template <typename BodyFunctor>
struct NAryTreeCEXForLoop<BodyFunctor, 1> {
  template <typename IType, IType Start, IType End, IType Inc,
            typename BoolExpressionFunctor,
            typename InitialTupleWithTypeEncodedNTTPs,
            typename InitialNonCEXDataFunctor>
  class With {
   private:
    using FunctorData = typename BodyFunctor::NonConstexprData;
    using FunctorOutputType = typename BodyFunctor::OutputType;

    static_assert(
        IntegralPow(10, 1) >=
            GetIterationCount<IType, Start, End, Inc, BoolExpressionFunctor>(),
        "Requested iteration is greater than supported maximum iteration "
        "count");

    template <IType LocalStart, IType LocalEnd,
              typename LocalInitialTupleWithTypeEncodedNTTPs,
              typename LocalInitialNonCEXDataFunctor>
    struct LinearExpansion0 {
      static constexpr IType kLocalIterationCount =
          GetIterationCount<IType, LocalStart, LocalEnd, Inc,
                            BoolExpressionFunctor>();

      static constexpr int GetEnabledIteration() {
        int return_value = -1;
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (0 * Inc), End)) {
          return_value = 0;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (1 * Inc), End)) {
          return_value = 1;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (2 * Inc), End)) {
          return_value = 2;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (3 * Inc), End)) {
          return_value = 3;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (4 * Inc), End)) {
          return_value = 4;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (5 * Inc), End)) {
          return_value = 5;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (6 * Inc), End)) {
          return_value = 6;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (7 * Inc), End)) {
          return_value = 7;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (8 * Inc), End)) {
          return_value = 8;
        } else {
          return return_value;
        }
        if (BoolExpressionFunctor::template WithType<IType>::func(
                LocalStart + (9 * Inc), End)) {
          return_value = 9;
        } else {
          return return_value;
        }
      }

      static constexpr auto kEnabledIterationCache = GetEnabledIteration();
      // Forward-declare iteration structs for partial template specialization
      // SFINAE
      template <typename UnusedType = void, typename Picker = void>
      struct INone;
      template <typename UnusedType = void, typename Picker = void>
      struct I0;
      template <typename UnusedType = void, typename Picker = void>
      struct I1;
      template <typename UnusedType = void, typename Picker = void>
      struct I2;
      template <typename UnusedType = void, typename Picker = void>
      struct I3;
      template <typename UnusedType = void, typename Picker = void>
      struct I4;
      template <typename UnusedType = void, typename Picker = void>
      struct I5;
      template <typename UnusedType = void, typename Picker = void>
      struct I6;
      template <typename UnusedType = void, typename Picker = void>
      struct I7;
      template <typename UnusedType = void, typename Picker = void>
      struct I8;
      template <typename UnusedType = void, typename Picker = void>
      struct I9;
  
      // Define partial template specializations for base iteration structs that
      // conditionaly instantiate the user BodyFunctor based on iteration count
      template <typename UnusedType>
      struct INone<UnusedType,
                   std::enable_if_t<kEnabledIterationCache == -1, void>> {
        static constexpr FunctorOutputType kPriorOutput = {
            LocalInitialNonCEXDataFunctor::value,
            NthTypeOfTuple<0, LocalInitialTupleWithTypeEncodedNTTPs>::value};
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue = kPriorOutput;
      };
      template <typename UnusedType>
      struct I0<UnusedType, std::enable_if_t<kEnabledIterationCache >= 0, void>> {
        static constexpr FunctorOutputType kPriorOutput = {
            LocalInitialNonCEXDataFunctor::value,
            NthTypeOfTuple<0, LocalInitialTupleWithTypeEncodedNTTPs>::value};
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 0),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I1<UnusedType, std::enable_if_t<kEnabledIterationCache >= 1, void>> {
        static constexpr FunctorOutputType kPriorOutput = I0<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 1),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I2<UnusedType, std::enable_if_t<kEnabledIterationCache >= 2, void>> {
        static constexpr FunctorOutputType kPriorOutput = I1<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 2),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I3<UnusedType, std::enable_if_t<kEnabledIterationCache >= 3, void>> {
        static constexpr FunctorOutputType kPriorOutput = I2<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 3),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I4<UnusedType, std::enable_if_t<kEnabledIterationCache >= 4, void>> {
        static constexpr FunctorOutputType kPriorOutput = I3<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 4),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I5<UnusedType, std::enable_if_t<kEnabledIterationCache >= 5, void>> {
        static constexpr FunctorOutputType kPriorOutput = I4<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 5),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I6<UnusedType, std::enable_if_t<kEnabledIterationCache >= 6, void>> {
        static constexpr FunctorOutputType kPriorOutput = I5<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 6),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I7<UnusedType, std::enable_if_t<kEnabledIterationCache >= 7, void>> {
        static constexpr FunctorOutputType kPriorOutput = I6<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 7),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I8<UnusedType, std::enable_if_t<kEnabledIterationCache >= 8, void>> {
        static constexpr FunctorOutputType kPriorOutput = I7<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 8),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      template <typename UnusedType>
      struct I9<UnusedType, std::enable_if_t<kEnabledIterationCache >= 9, void>> {
        static constexpr FunctorOutputType kPriorOutput = I8<>::kValue;
  
        // NOLINTNEXTLINE(readability-identifier-naming)
        static constexpr auto kValue =
            BodyFunctor::template func<(LocalStart + 9),
                                       std::get<1>(kPriorOutput)>(
                std::get<0>(kPriorOutput));
      };
      // Create SFINAE function that returns the value from the last iteration
      template <IType LocalLocalIterationCount = kLocalIterationCount>
      static constexpr auto func()
          -> std::enable_if_t<LocalLocalIterationCount == 0, FunctorOutputType> {
        return INone<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 0, FunctorOutputType> {
        return I0<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 1, FunctorOutputType> {
        return I1<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 2, FunctorOutputType> {
        return I2<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 3, FunctorOutputType> {
        return I3<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 4, FunctorOutputType> {
        return I4<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 5, FunctorOutputType> {
        return I5<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 6, FunctorOutputType> {
        return I6<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 7, FunctorOutputType> {
        return I7<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 8, FunctorOutputType> {
        return I8<>::kValue;
      }
      template <int LastEnabledI = kEnabledIterationCache>
      static constexpr auto func()
          -> std::enable_if_t<LastEnabledI == 9, FunctorOutputType> {
        return I9<>::kValue;
      }
    };

   public:
    static constexpr FunctorOutputType func() {
      return LinearExpansion0<Start, End, InitialTupleWithTypeEncodedNTTPs,
                              InitialNonCEXDataFunctor>::func();
    }
  };
};

}  // namespace impl
}  // namespace cex_for_loop

#endif  // NARY_TREE_CEX_FOR_LOOP_IMPL_H
